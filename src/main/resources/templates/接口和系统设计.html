<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>接口和系统设计</title>
	  <link href="/toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
	  <link href="/toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>

  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h2 id="1-">1. 如何写出可靠的接口</h2>
<p>第一条建议：严格校验用户的输入，包括格式、内容。</p>
<p>第二条建议：考虑用户的骚操作，重复提交、延时提交</p>
<p>重复提交，也就是接口的幂等性，有些资源只能操作一次，必须进行校验，其实不仅是重复提交，还包括同一事件被两人重复处理的情况。</p>
<p>而对于延时提交，其实是测试给我提bug后我才意识到的问题模式。例如我们通过get接口返回给用户某种资源，用户可以通过post接口回传资源id并提交修改，由于是自己的get接口返回的，我们可能想着只验证id合法就行了，看似形成严格闭环，但如果用户停留在此页面延时提交，则可能在此期间资源过期，或者资源已被他人修改，而改用户也成功修改的bug。</p>
<p>其实进一步思考，你会发现，这跟高并发情景下的资源失效有异曲同工之处。</p>
<p>第三条建议：检验数据库、第三方接口的返回数据</p>
<p>除了用户输入，常见的数据来源还有数据库、第三方接口。相对而言，这些数据接口会可靠的多，而且内容格式也更规范。
不过为了接口的稳定性，最好也做一些检验。如常见的数据为空的情况，就要及时中止程序执行并抛出合适的信息。</p>
<p>三. 如何写出更高效的接口</p>
<p>最后，再写一点点关于关于接口效率、代码质量的思考。</p>
<ol>
<li><p>影响接口效率的主要是数据库操作</p>
<p> 以我有限的经历来看，接口耗时长基本都是因为数据库操作不合理，我们大多数的业务代码并不会有性能问题。我见过不少在for循环里查询数据库的代码，一定要避免，我们可以先一次性取出所有数据，然后逐个去处理。例如我们会在框架层记录所有数据库操作，调试接口时即可看到所有数据库操作以及相应耗时，该合并的查询要合并，该优化的耗时查询相应去优化。</p>
</li>
<li><p>合理使用Exception，日志</p>
<p> 这条主要针对php语言，由于历史原因，我看到不少代码靠return中止程序并传递错误信息，这样在代码复杂、调用层次深了以后极难维护，远没有Exception机制直观方便。还有，重要信息一定要写日志，便于后期发现问题及调试，
也可用来自证清白。</p>
</li>
<li><p>代码要合理划分、抽象</p>
<p> 不要复制粘贴代码，重复的功能要独立出来；设计时要合理考虑需求变更、扩展；写小而专注的函数，不要把复杂功能一坨实现；这样写的代码才易于修改、测试以及扩展。这块我做的也不好，上线后看自己的代码都是一坨一坨，难以维护，接下来还要多思考，多实践。</p>
</li>
</ol>
<h2 id="2-">2.设计线程池</h2>
<p>那线程池设计需要考虑的点：</p>
<ul>
<li><p>线程池状态：</p>
<ul>
<li>有哪些状态？如何维护状态？</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li>线程怎么封装？线程放在哪个池子里？</li>
<li>线程怎么取得任务？</li>
<li>线程的数量怎么限制？动态变化？自动伸缩？</li>
<li>线程怎么消亡？如何重复利用？</li>
</ul>
</li>
<li><p>任务</p>
<ul>
<li>任务少可以直接处理，多的时候，放在哪里？</li>
<li>任务队列满了，怎么办？</li>
<li>用什么队列？</li>
</ul>
</li>
<li><p>如果从任务的阶段来看，分为以下几个阶段：</p>
<ul>
<li>如何存任务？</li>
<li>如何取任务？</li>
<li>如何执行任务？</li>
<li>如何拒绝任务？</li>
</ul>
</li>
</ul>
<h3 id="-">线程怎么封装？线程放在哪个池子里？</h3>
<p>假设封装成为 Worker线程, Worker线程调用给定Runnable的Run()方法</p>
<p>可以考虑使用 HashSet 来存储线程，也就是充当线程池的角色，当然，HashSet 会有线程安全的问题需要考虑，那么我们可以考虑使用一个可重入锁比如 ReentrantLock，凡是增删线程池的线程，都需要锁住。</p>
<h3 id="-">线程怎么取得任务？</h3>
<p>运行完任务的线程，应该继续取任务，取任务肯定需要从任务队列里面取，要是任务队列里面没有任务，由于是阻塞队列，那么可以等待，如果等待若干时间后，仍没有任务，倘若该线程池的线程数已经超过核心线程数，并且允许线程消亡的话，应该将该线程从线程池中移除，并结束掉该线程。</p>
<h3 id="-">线程怎么消亡？如何重复利用？</h3>
<p>消亡只是结束了它的run()方法，当线程池数量需要自动缩容的，就会让一部分空闲的线程结束。</p>
<p>而重复利用，其实是执行完任务之后，再去去任务队列取任务，取不到任务会等待，任务队列是一个阻塞队列，这是一个不断循环的过程。</p>
<h3 id="-">线程的数量怎么限制？动态变化？自动伸缩？</h3>
<ul>
<li>来一个任务创建一个线程处理，直到线程数达到核心线程数。</li>
<li>达到核心线程数之后且没有空闲线程，来了任务直接放到任务队列。</li>
<li>任务队列如果是无界的，会被撑爆。</li>
<li>任务队列如果是有界的，任务队列满了之后，还有任务过来，会继续创建线程处理，此时线程数大于核心线程数，直到线程数等于最大线程数。</li>
<li>达到最大线程数之后，还有任务不断过来，会触发拒绝策略，根据不同策略进行处理。</li>
<li>如果任务不断处理完成，任务队列空了，线程空闲没任务，会在一定时间内，销毁，让线程数保持在核心线程数即可。</li>
</ul>
<h2 id="3-">3.设计接口步骤</h2>
<ol>
<li>想清楚这个接口是干什么的</li>
<li>接口会与哪些接口进行交互</li>
<li>使用什么协议交互 （http https ftp）</li>
<li>设置接口路径</li>
<li><p>http请求方式</p>
<p> 接口基本访问协议：get(获取)，post(新增)，put(修改)和delete(删除)</p>
<p> get     /users：列出所有用户</p>
<p> post   /user：新增用户</p>
<p> put      /user/id：根据用户id更新用户</p>
<p> delete   /user/id：根据用户id删除用户</p>
</li>
<li><p>返回数据格式</p>
<p> 返回数据格式，一般包括三个字段：</p>
<pre><code> private int code; //状态码

 private String msg; //信息

 private T data; 
</code></pre></li>
</ol>
<ol start="7">
<li><p>设计接口具体内容</p>
</li>
<li><p>api安全考虑</p>
</li>
</ol>
<p>链接 <a href="https://www.cnblogs.com/wangjiming/p/10256546.html">如何设计一个良好的接口</a></p>
<h2 id="4-">4.接口幂等性</h2>
<h3 id="4-1-">4.1 什么是接口幂等性？</h3>
<p>幂等性用在接口上就可以理解为：同一个接口，多次发出同一个请求，必须保证操作只执行一次。</p>
<h3 id="4-2-">4.2 为什么会产生接口幂等性问题？</h3>
<ul>
<li>网络波动, 可能会引起重复请求</li>
<li>用户重复操作,用户在操作时候可能会无意触发多次下单交易,甚至没有响应而有意触发多次交易应用</li>
<li>使用了失效或超时重试机制(Nginx重试、RPC重试或业务层重试等)
页面重复刷新</li>
<li>使用浏览器后退按钮重复之前的操作,导致重复提交表单</li>
<li>使用浏览器历史记录重复提交表单</li>
<li>浏览器重复的HTTP请求</li>
<li>定时任务重复执行</li>
<li>用户双击提交按钮</li>
</ul>
<h3 id="4-3-">4.3 如何保证接口幂等性？</h3>
<p>解决办法分为两个方向</p>
<ul>
<li>客户端防止重复调用</li>
<li><p>服务端进行校验。</p>
</li>
<li><p>按钮只可操作一次</p>
<p> 一般是提交后把按钮置灰或loding状态,消除用户因为重复点击而产生的重复记录。</p>
</li>
<li><p>token机制</p>
<p> 功能上允许重复提交,但要保证重复提交不产生副作用,比如点击n次只产生一条记录,具体实现就是进入页面时申请一个token,然后后面所有的请求都带上这个token,后端根据token来避免重复请求。</p>
<ul>
<li>服务端生成token并放入redis</li>
<li>客户端获取token， 业务请求时带上token</li>
<li>服务端查看token是否存在</li>
<li>token存在就删除，并执行请求</li>
<li>不存在就不执行，返回重复标记</li>
</ul>
</li>
<li><p>分布式锁</p>
<p> 如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志(用户ID+后缀等)获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁(分布式锁要第三方系统提供)。</p>
</li>
<li><p>缓冲队列</p>
<p> 将请求都快速地接收下来后放入缓冲队列中,后续使用异步任务处理队列中的数据,过滤掉重复的请求,该解决方案优点是同步处理改成异步处理、高吞吐量,缺点则是不能及时地返回请求结果,需要后续轮询得处理结果。</p>
</li>
</ul>
<p>链接：</p>
<p><a href="https://www.cnblogs.com/linjiqin/p/9678022.html">高并发下接口幂等性解决方案</a></p>
<p><a href="https://www.cnblogs.com/three-fighter/p/14054749.html">什么是接口幂等性？</a></p>
<h2 id="5-api-">5.如何解决api接口的并发问题？</h2>
<ol>
<li><p>通过控制并发数量来实现</p>
<p> Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p>
</li>
<li><p>通过控制访问速率来实现</p>
<p> 这种方式采用令牌桶算法来实现，我们以一个恒定的速率向一个桶内放令牌，每次请求来的时候去桶里拿令牌，如果拿到了就继续后面的操作，如果没有拿到则等待。</p>
<p> 在我们的工程实践中，通常使用Google开源工具包Guava提供的限流工具类RateLimiter来实现控制速率，该类基于令牌桶算法来完成限流，非常易于使用，而且非常高效。如我们不希望每秒的任务提交超过1个。</p>
</li>
<li><p>Nginx 限流
Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数。</p>
</li>
<li><p>控制速率
  我们需要使用 limit_req_zone 用来限制单位时间内的请求数</p>
<p>  若限制每个 IP 访问的速度为 2r/s，因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。</p>
<p>  我们使用单 IP 在 10ms 内发并发送了 6 个请求的执行结果如下：</p>
<p>  从以上结果可以看出他的执行符合我们的预期，只有 1 个执行成功了，其他的 5 个被拒绝了（第 2 个在 501ms 才会被正常执行）。</p>
</li>
<li><p>速率限制升级版</p>
<p>  上面的速率控制虽然很精准但是应用于真实环境未免太苛刻了，真实情况下我们应该控制一个 IP 单位总时间内的总访问次数，而不是像上面那么精确但毫秒，我们可以使用 burst 关键字开启此设置。</p>
<p>  burst=4 表示每个 IP 最多允许4个突发请求，如果单个 IP 在 10ms 内发送 6 次请求的结果如下：</p>
<p>  从以上结果可以看出，有 1 个请求被立即处理了，4 个请求被放到 burst 队列里排队执行了，另外 1 个请求被拒绝了。</p>
</li>
</ol>
<p>链接: <a href="https://zhuanlan.zhihu.com/p/141733902">6种 分布式限流方案，我替你整理好了</a></p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="/toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="/toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="/toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="/toc/js/toc_conf.js"></script>

<SCRIPT type="text/javascript" >
//<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>